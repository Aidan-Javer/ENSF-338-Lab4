# Question 6
1. When comparing Arrays vs. Linked Lists, the main advantage of the former is that it's easier to setup and use compared to the latter, and the act of changing an element at a given index point is far more trivial, in part due to the fact that the data is contiguously stored. However, the insertion/deletion of elements may be awkward, the array being dynamically sized - while useful - also takes up unnecessary space, and a fixed size array either limits the size (implied) or wastes space if said space isn't used. In comparison, Linked Lists are resizable, and won't actively waste space if it's unneeded. The data is also non-contiguous, thus preventing the need to constantly increase the capacity of the list in order to prevent pre-existing addresses from being overwritten, proving itself to be far more memory efficient. A disadvantage is that it's not easily indexable, however insertions and deletions are far more intuitive as well.

2. Assuming that the order of the array is unknown, a linear search for the element would first be required. Once the element is found, replacing the pre-existing element with the new one is as simple as `a[i] = b` where a is the array of n elements, i is the index, and b is the element that is replacing the element located at `a[i]`. If it were just an insertion/deletion, the elements would have to be shifted accordingly, either to make room for the insertion or eliminate the empty element from the deletion. But given that it's both, the shifts counteract each other; they are not needed. This would have a time complexity of O(1), though searching for the element that needs to be replaced could be considered O(n) in the average/worst-case scenarios.

3. Given a doubly linked list, the feasibility of utilizing either an Insertion Sort [1] or Merge Sort [2] will be discussed.
	1. With an insertion sort, the algorithm checks through each index in the array and performs swaps if deemed necessary. The first index is presumed to be sorted, and every other index after is inserted into the sorted section of elements through the means of comparisons. For the sake of traversal through the data structure, the pointer must be able to go back and forward from one index to another. **It is feasible to implement a doubly linked list with this sorting algorithm.** The algorithm can simply traverse via tail/head pointers from the nodes, and the act of insertion can be done so by swapping the two nodes, changing their pointers accordingly. Though, it may be preferable for smaller linked lists, akin to arrays.

	3. With a merge sort, the algorithm divides the array into two halves recursively until there exists only one element in each and every subarray. Afterwards, the values of these subarrays gets merged together, eventually finding their way back into the main function. The merge process involves the creation of two temporary arrays which are filled with the values of the subarrays being merged, and those two temp arrays are then compared amongst each other, placing values back into the merged array whenever applicable. **As with before, it is is absolutely feasible to implement a doubly linked list here.** The divide aspect of this algorithm can simply be handled like an array; splitting the linked list into smaller and smaller segments. As for the conquer aspect, instead of copying over elements and comparing them, the node values themselves can be compared directly and the pointers can be swapped around as deemed necessary. This also saves on extra space.

4. The complexity of both the Merge Sort and the Insertion Sort shouldn't differ wildly from their original counterparts. In the case of the Merge Sort, the swapping of pointers ultimately has a time complexity of O(n), as the algorithm only iterates and compares the values of the current input size given. Splitting is also O(n), and the overall complexity of the algorithm is O(nlog(n)), as log(n) represents the recursion levels present in the algorithm. [An array of 8 elements must divide upon itself 3 times recursively]. As for Insertion Sort, It's a similar story. There might be the benefit of O(1) when inserting a node, as elements no longer need to be shifted, but finding the insertion point for said element whilst iterating upon each element in the array leads to a time complexity of O(n<sup>2</sup>).
