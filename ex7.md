

# Exercise 7
1. Looking at the function, the for loop on the outside has a time complexity of O(n), as it iterates through all the elements of the linked list starting from its end, and copies them over to a new linked list instead. The last element would then become the first. in the new List. Additionally, through each and every iteration of the loop, `get_element_at_pos(i)` is also called. This function iterates through the linked list given the node's position, and returns the corresponding value. Thus, given that the best-case complexity is O(1), and the worst/average-case complexity is O(n) (as the function may have to go through the majority of the linked list in order to get the element. Thus, the total time complexity of reverse(self) is O(n) * O(n) = O(n<sup>2</sup>). The rest of the code in reverse(self) only serves to either compare nodes alongside building the new linked list. They all have a time complexity of O(1). None of which are more complex than O(n). 
2. In the simplest sense, to reverse a singly-linked list all that really needs to be done is set the head pointer to start at the end of the array, and reverse the direction of each and every pointers until the beginning is reached. The function reverse_updated(self) starts at the head pointer, and while the current pointer is still pointing to a node, the function will simply swap the direction of the pointers between the nodes, updating the current and previous nodes in the function. This has a time complexity of O(n) as there is no need to create a separate linked list alongside only needing to use one loop to iterate through the nodes. When when compared with the efficiency of the original reverse function later on, it completes the tasks in literal milliseconds compared to seconds.
