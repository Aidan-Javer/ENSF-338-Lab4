# Question 5
1. timeit essentially runs the code snippet provided via the function a number of times specified by the users. With the following example:
`elapsed_time  =  timeit.timeit(lambda:  fibonacci(1000), number=100)`
The Fibonacci function will receive the argument 1000, and timeit.timeit will return the total elapsed time across the 100 runs of fibonacci(1000). timeit.timeit should be used when one significant measurement is enough. Such cases are moreso appliable to optimizing smaller snippets of code, where the execution time will remain far more consistent. Also useful for a rough estimation.
On the other hand, repeat serves to run timeit itself multiple times, which will run the it's corresponding function. Looking at the following example:
`times =  timeit.repeat(lambda:  fibonacci(1000), repeat =5, number=10)`
Fibonacci(1000) will be run a total of 10 times initially. After those 10 runs, the elapsed time will be added to an array that'll be returned after timeit.timeit is run 5 more times. Thus, an array of 5 elements, each representing the elapsed_time of the 10 runs of fibonacci(1000). This is far more preferable if we wish to see the variation in times across multiple runs. It provides us with more accurate data as well, as a result of the multiple trials being recorded. Useful in instances of testing snippets of code where the execution time might be more unstable, or when more complex pieces of code need to be analyzed.

2. For timeit.timeit(), the appropriate statistic to apply to its output would the _average_. Referring back to `elapsed_time  =  timeit.timeit(lambda:  fibonacci(1000), number=100)`, the elapsed time returns the total time across the number of runs performed on the code itself. Thus, dividing the elapsed_time by 100 gives us the average time spent per run. If we wanted to perform a more detailed analysis, we could apply the _minimum/maximum_ to the output of timeit.repeat(). Referring back to `times =  timeit.repeat(lambda:  fibonacci(1000), repeat =5, number=10)`, times essentially contains an array of 5 elements, each element represents the time spent across 10 runs. We can find the smallest/largest value in this array, and divide accordingly by the number of runs to derive an estimation of the ceiling/floor of the execution time. 
